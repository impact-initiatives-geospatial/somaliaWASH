---
title: "aa-selecting_assessment_indicators"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{aa-selecting_assessment_indicators}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(here)
library(tidyverse)
# library(somaliaWASH)
devtools::load_all()
```

## Intro
Suggest following a [markdown first](https://rtask.thinkr.fr/when-development-starts-with-documentation/) approach to this analysis.

## Loading and selecting data

Following the markdown first approach you would write the functions directly in the markdown chunk below and then demonstrate how they work in the subsequent chunk. Once you are confident they are working as desired. Copy the functions to new files in the `R/` folder and remove this chunk leaving only the example demonstration here:

```{r}

#' load_h2r_data
#'
#' @return
#' @export
#' @description function to load H2R data set - will use environment key to specify base data directory
#' @examples
load_h2r_data <-  function(main_folder_path, data_path){
  
  # main_folder_path <-  Sys.getenv("SOM_2203_WASH_DATA")
  # data_path <- "data/202209/raw/REACH_H2R_0522-2607_data2.csv"
  
  h2r_data <- readr::read_csv(file.path(main_folder_path, data_path))
  
  return(h2r_data)
}

#' select_h2r_indicators
#'
#' @return
#' @export
#' @description function to select relevant h2r indicators from data set
#' @examples
select_h2r_indicators <- function(input_df, country_code="som"){
  if(country_code=="som"){
    h2r_cols <- list(
      `uuid` = "uuid",
      `District` = "district_info",
      `Hex` = "hex_4000km",
      `Base` = "base",
      `info settlement` = "info_settlement",
      `Latitude` = "latitude",
      `Longitude` = "longitude",
      `Flood` = "climatic_shock.flood",
      `Failed rains` = "climatic_shock.no_rain",
      `Drought` = "climatic_shock.drought",
      `Locust invation` = "climatic_shock.locusts",
      `Wild fires` = "climatic_shock.fires",
      `Crop loss reasons` = "crop_loss_reasons",
      `Crop loss reasons locusts` = "crop_loss_reasons.locusts",
      `Crop loss reasons no rain` = "crop_loss_reasons.no_rain",
      `Crop loss reasons flooding` = "crop_loss_reasons.flooding",
      `Crop loss reasons no irrigation` = "crop_loss_reasons.no_irrigation",
      `Crop loss reasons high temperature` = "crop_loss_reasons.high_temperature",
      `Crop loss reasons other` = "crop_loss_reasons.other",
      `Reason moved` = "primary_reason_moved",
      `Reason moved to access water` = "primary_reason_moved.access_water",
      `Reason moved to access food` = "primary_reason_moved.access_food",
      `Reason moved to better security` = "primary_reason_moved.better_security",
      `Reason moved to jobsa vailable` = "primary_reason_moved.jobsa_vailable",
      `Reason moved to shelters available` = "primary_reason_moved.shelters_available",
      `Reason moved to better services` = "primary_reason_moved.better_services",
      `New IDP arrivals` = "idp_new_arrivals",
      `New IDP arrivals reason climatic shock` = "idp_arrived_reason.climatic_shock",
      `New IDP arrivals reason lack food` = "idp_arrived_reason.lack_food",
      `New IDP arrivals reason lack water` = "idp_arrived_reason.lack_water",
      `New IDP arrivals reason lack income` = "idp_arrived_reason.lack_income",
      `New IDP arrivals reason no services` = "idp_arrived_reason.no_services",
      `New IDP arrivals reason eviction` = "idp_arrived_reason.eviction",
      `New IDP arrivals reason insecurity` = "idp_arrived_reason.insecurity",
      `IDP pull factors` = "idp_pull_factors",
      `IDP pull factors water` = "idp_pull_factors.access_water",
      `IDP pull factors food` = "idp_pull_factors.access_food",
      `IDP pull factors security` = "idp_pull_factors.better_security",
      `IDP pull factors jobs` = "idp_pull_factors.presence_jobs",
      `IDP pull factors shelters` = "idp_pull_factors.availability_shelters",
      `IDP pull factors services` = "idp_pull_factors.better_services",
      `HC push main` = "hc_push_main",
      `Main source water` = "mainsource_water",
      `Responsible water fetching` = "responsible_water_fetching",
      `Surfacewater drinking` = "surfacewater_drinking",
      `Gettingwater time` = "gettingwater_time",
      `Water sufficient lastmonth` = "water_sufficient_lastmonth",
      `Stagnant water near` = "stagnant_water_near",
      `People using latrines` = "people_using_latrines",
      `Barriers usetoilets no barrier` = "barriers_usetoilets.no_barrier",
      `Barriers usetoilets not available` = "barriers_usetoilets.not_available",
      `Barriers usetoilets insufficient` = "barriers_usetoilets.insufficient",
      `Barriers usetoilets not funtional` = "barriers_usetoilets.not_funtional",
      `Barriers usetoilets overcrowded` = "barriers_usetoilets.overcrowded",
      `Barriers usetoilets too dirty` = "barriers_usetoilets.too_dirty",
      `Barriers usetoilets too far` = "barriers_usetoilets.too_far",
      `Barriers usetoilets not common` = "barriers_usetoilets.not_common",
      `Barriers usetoilets women notsafe` = "barriers_usetoilets.women_notsafe",
      `Barriers usetoilets pwd notsafe` = "barriers_usetoilets.pwd_notsafe",
      `Barriers usetoilets child notsafe` = "barriers_usetoilets.child_notsafe",
      `Barriers usetoilets night notsafe` = "barriers_usetoilets.night_notsafe",
      `Waste disposal` = "waste_disposal",
      `Hand washing access` = "handwashing_access"
    )  
  }
  
  df_h2r_cols <- input_df |> 
    select(purrr::map_chr(h2r_cols, ~.x))
  return(df_h2r_cols)
}


#' load_h2r_indictors
#'
#' @return
#' @export
#' @description combination of `load_h2r_data` and `select_h2r_indicators` to quicky load only data with only relelvant indicators
#' @examples
load_h2r_indicators <-  function(){
  df <-load_h2r_data()
  
  df |> 
    select_h2r_indicators(country_code="som")
    
}

```


## Finding the appropriate data set:

Have a look at all the datasets available in the project.

```{r}

# data set list (?ds_ls())
ds_ls()

```

use shortened easy to remember names to access file paths:

```{r}
# ?ds_find() - stands for data set find
ds_find(ds = "2205_h2r_settlement")

```


this can be wrapped in various load functions like `load_swp()` which loads the Strageic Water Point data.
`TODO:` not priority, but later we can refactor code to just have one `load_*()` function which loads correct data based on argument
```{r}

swp <-  load_swp()
```



# simple point aggregations to grid


```{r}

swp_sf <- swp |>
     sf::st_as_sf(coords=c("longitude","latitude"), crs=4326)

 # just aggregate point counts
wp_n_grid_utm <- swp_sf |>
    hex_aggregate_pt_count(hex = som_hex)

# aggregate point counts based on `var`- `val` combination
swp_n_grid_utm <- swp_sf |>
    hex_aggregate_pt_count(hex = som_hex,var = "is_strategic",var_val = "yes")

```

let's just map for fun
```{r}
library(leaflet)
library(leafgl) # for faster rendering large polygon datasets

# for leaflet - convert back to wgs84

wp_n_grid <- wp_n_grid_utm |> 
  sf::st_transform(crs= 4326) |> 
  sf::st_cast("POLYGON") # just leafgl can't handle multipolygons

leaflet() |> 
  addTiles() |> 
  leafgl::addGlPolygons(data = wp_n_grid,
                        fillColor = ~count,
                        popup =~count) 
  



```


```
